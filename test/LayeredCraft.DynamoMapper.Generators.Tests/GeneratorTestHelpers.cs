using Basic.Reference.Assemblies;
using DynamoMapper;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace LayeredCraft.DynamoMapper.Generators.Tests;

/// <summary>
///     Extends <see cref="CodeGenerationOptions" /> with additional options for verification
///     testing.
/// </summary>
internal class VerifyTestOptions : CodeGenerationOptions
{
    /// <summary>
    ///     Gets or initializes the expected number of syntax trees to be generated by the source
    ///     generator.
    /// </summary>
    internal int ExpectedTrees { get; init; } = 1;
}

/// <summary>Configuration options for code generation testing.</summary>
internal class CodeGenerationOptions
{
    /// <summary>Gets or initializes the source code to compile and test.</summary>
    internal required string SourceCode { get; init; }

    /// <summary>Gets or initializes the file path for the source code.</summary>
    internal string CodePath { get; init; } = "InputFile.cs";

    /// <summary>Gets or initializes the C# language version to use for compilation.</summary>
    internal LanguageVersion LanguageVersion { get; init; } = LanguageVersion.CSharp14;

    /// <summary>Gets or initializes optional diagnostics to suppress during compilation.</summary>
    internal Dictionary<string, ReportDiagnostic>? DiagnosticsToSuppress { get; init; } = null;

    /// <summary>Gets or initializes the name of the test assembly.</summary>
    internal string AssemblyName { get; init; } = "TestsAssembly";

    /// <summary>Gets or initializes additional language features to enable during compilation.</summary>
    internal IEnumerable<KeyValuePair<string, string>> LanguageFeatures { get; init; } = [];
}

internal static class GeneratorTestHelpers
{
    internal static Task Verify(VerifyTestOptions options)
    {
        var (driver, originalCompilation) = GenerateFromSource(options);

        driver.Should().NotBeNull();

        var result = driver.GetRunResult();

        // Reparse generated trees with the same parse options as the original compilation
        // to ensure consistent syntax tree features (e.g., InterceptorsNamespaces)
        var parseOptions = originalCompilation.SyntaxTrees.First().Options;
        var reparsedTrees = result
            .GeneratedTrees.Select(tree =>
                CSharpSyntaxTree.ParseText(tree.GetText(), (CSharpParseOptions)parseOptions)
            )
            .ToArray();

        // Add generated trees to original compilation
        var outputCompilation = originalCompilation.AddSyntaxTrees(reparsedTrees);

        var errors = outputCompilation
            .GetDiagnostics()
            .Where(d => d.Severity == DiagnosticSeverity.Error)
            .ToList();

        errors
            .Should()
            .BeEmpty(
                "generated code should compile without errors, but found:\n"
                    + string.Join(
                        "\n---\n",
                        errors.Select(e => $"  - {e.Id}: {e.GetMessage()} at {e.Location}")
                    )
            );

        result.GeneratedTrees.Length.Should().Be(options.ExpectedTrees);

        return Verifier.Verify(driver).UseDirectory("Snapshots").DisableDiff();
    }

    internal static (GeneratorDriver driver, Compilation compilation) GenerateFromSource(
        CodeGenerationOptions options
    )
    {
        var parseOptions = CSharpParseOptions
            .Default.WithLanguageVersion(options.LanguageVersion)
            .WithFeatures(options.LanguageFeatures);

        var syntaxTree = CSharpSyntaxTree.ParseText(
            options.SourceCode,
            parseOptions,
            options.CodePath
        );

        List<MetadataReference> references =
        [
#if NET10_0_OR_GREATER
            .. Net100.References.All.ToList(),
#elif NET9_0
            .. Net90.References.All.ToList(),
#else
            .. Net80.References.All.ToList(),
#endif
        ];

        var compilationOptions = new CSharpCompilationOptions(
            OutputKind.ConsoleApplication,
            nullableContextOptions: NullableContextOptions.Enable
        ).WithSpecificDiagnosticOptions(options.DiagnosticsToSuppress);

        if (options.DiagnosticsToSuppress is not null)
            compilationOptions = compilationOptions.WithSpecificDiagnosticOptions(
                options.DiagnosticsToSuppress
            );

        var compilation = CSharpCompilation.Create(
            "TestsAssembly",
            [syntaxTree],
            references,
            compilationOptions
        );

        var generator = new DynamoMapperGenerator().AsSourceGenerator();

        var driver = CSharpGeneratorDriver.Create(generator);
        var updatedDriver = driver.RunGenerators(compilation, CancellationToken.None);

        return (updatedDriver, compilation);
    }
}
